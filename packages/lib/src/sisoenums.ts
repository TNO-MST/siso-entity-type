import { EntityKindDescriptions, SisoEnum, Utils, type SisoEnumsDataType } from "./index.js";

import debugEsm from "debug";
const debug = debugEsm("SISO:enums");

// Bitmaps for entity type fields
export const BITMAP_0 = 0n;
export const BITMAP_KIND = 0xff00000000000000n;
export const BITMAP_KIND_DOMAIN = 0xffff000000000000n;
export const BITMAP_KIND_DOMAIN_COUNTRY = 0xffffffff00000000n;
export const BITMAP_COUNTRY = 0x0000ffff00000000n;
export const BITMAP_COUNTRY_CAT = 0xffffffffff000000n;
export const BITMAP_COUNTRY_CAT_SUBCAT = 0xffffffffffff0000n;
export const BITMAP_COUNTRY_CAT_SUBCAT_SPECIFIC = 0xffffffffffffff00n;
export const BITMAP_0_CAT = 0xffff0000ff000000n;
export const BITMAP_0_CAT_SUBCAT = 0xffff0000ffff0000n;
export const BITMAP_0_CAT_SUBCAT_SPECIFIC = 0xffff0000ffffff00n;
export const BITMAP_0_CAT_SUBCAT_SPECIFIC_EXTRA = 0xffff0000ffffffffn;

export const BITMAP_BYTE = 0xffn;
export const BITMAP_SHORT = 0xffffn;

export class SisoEnums {
  private mapKind: Map<bigint, string> = new Map();
  private mapDomain: Map<bigint, string> = new Map();
  private mapCountry: Map<bigint, string> = new Map();
  private mapCategory: Map<bigint, string> = new Map();

  constructor(enumsMap?: SisoEnumsDataType) {
    if (enumsMap != null) {
      this.initialize(enumsMap);
    }
  }

  private get countryCount() {
    return this.mapCountry.size;
  }

  private get kindCount() {
    return this.mapKind.size;
  }

  private get domainCount() {
    return this.mapDomain.size;
  }

  private get categoryCount() {
    return this.mapCategory.size;
  }

  // Loads the SISO enumeration data from a json file generated by the parser, either from an url when using a browser
  // or from the filesystem provided enumeration map when testing or running in NodeJS
  public async initialize(enumsMap: SisoEnumsDataType) {
    if (enumsMap == null) {
      throw new Error(`No enums map loaded, see README instructions`);
    } else {
      debug("Loading SISO enums from data...");
    }
    for (const [key, val] of Object.entries(enumsMap.countries)) {
      this.mapCountry.set(BigInt(key), val);
    }
    for (const [key, val] of Object.entries(enumsMap.categories)) {
      this.mapCategory.set(BigInt(key), val);
    }
    for (const [key, val] of Object.entries(enumsMap.domains)) {
      this.mapDomain.set(BigInt(key), val);
    }
    // Kinds are not loaded from the SISO enums datafile, but from the hardcoded EntityKind enum
    for (const [key, val] of Object.entries(EntityKindDescriptions)) {
      this.mapKind.set((BigInt(key) & BITMAP_BYTE) << 56n, val);
    }
    debug(`Processed ${this.countryCount} countries`);
    debug(`Processed ${this.kindCount} kinds`);
    debug(`Processed ${this.domainCount} domains`);
    debug(`Processed ${this.categoryCount} categories`);
  }

  public getOrDefault(entityType: bigint, defaultValue: string = "No description found"): string {
    let text =
      this.mapCategory.get(entityType) ??
      this.mapCategory.get(entityType & BITMAP_0_CAT_SUBCAT_SPECIFIC_EXTRA) ??
      this.mapCategory.get(entityType & BITMAP_COUNTRY_CAT_SUBCAT_SPECIFIC) ??
      this.mapCategory.get(entityType & BITMAP_0_CAT_SUBCAT_SPECIFIC) ??
      this.mapCategory.get(entityType & BITMAP_COUNTRY_CAT_SUBCAT) ??
      this.mapCategory.get(entityType & BITMAP_0_CAT_SUBCAT) ??
      this.mapCategory.get(entityType & BITMAP_COUNTRY_CAT) ??
      this.mapCategory.get(entityType & BITMAP_KIND_DOMAIN_COUNTRY) ??
      this.mapCategory.get(entityType & BITMAP_0_CAT) ??
      this.mapCategory.get(entityType & BITMAP_KIND_DOMAIN) ??
      defaultValue;
    if (text == null) {
      text = defaultValue;
    }
    this.mapCategory.set(entityType, text);
    return text;
  }

  public getDomainOrDefault(entityType: bigint, defaultValue?: string): string | null {
    let text =
      this.mapDomain.get(entityType & BITMAP_KIND_DOMAIN) ??
      this.mapDomain.get(entityType & BITMAP_KIND) ??
      this.mapDomain.get(BITMAP_0) ??
      defaultValue;
    if (text == null) {
      return null;
    }
    this.mapDomain.set(entityType, text);
    return text;
  }

  public getAllCountries(): Map<number, string> {
    const result = new Map<number, string>();
    this.mapCountry.forEach((value, key) => {
      result.set(Number(key >> 32n), value);
    });
    return result;
  }

  public getAllDomains(): Map<number, string> {
    const result = new Map<number, string>();
    this.mapDomain.forEach((value, key) => {
      result.set(Number(key >> 48n), value);
    });
    return result;
  }

  public getAllKinds(): Map<number, string> {
    const result = new Map<number, string>();
    this.mapKind.forEach((value, key) => {
      result.set(Number(key >> 56n), value);
    });
    return result;
  }

  public getAllDomainsOf(kind: number): Map<number, string> {
    return new Map(
      [...this.mapDomain.entries()]
        .filter(([k]) => Number((k >> 56n) & BITMAP_BYTE) === kind)
        .map(([k, v]) => [Number((k >> 48n) & BITMAP_BYTE), v]),
    );
  }

  public getCountry(country: number): string {
    return this.getAllCountries().get(country) || `Invalid country ${country}`;
  }

  public getAllCategoriesOf(kind: number, domain: number, country: number): Map<number, string> {
    return new Map(
      [...this.mapCategory.entries()]
        .filter(([k]) => Number((k >> 56n) & BITMAP_BYTE) === kind)
        .filter(([k]) => Number((k >> 48n) & BITMAP_BYTE) === domain)
        .filter(([k]) => {
          const c = Number((k >> 32n) & BITMAP_SHORT);
          return c === country || c === 0;
        })
        .filter(([k]) => Number((k >> 16n) & BITMAP_BYTE) === 0)
        .filter(([k]) => Number((k >> 8n) & BITMAP_BYTE) === 0)
        .filter(([k]) => Number(k & BITMAP_BYTE) === 0)
        .map(([k, v]) => [Number((k >> 24n) & BITMAP_BYTE), v]),
    );
  }

  public getAllSubcategoriesOf(kind: number, domain: number, country: number, category: number): Map<number, string> {
    return new Map(
      [...this.mapCategory.entries()]
        .filter(([k]) => Number((k >> 56n) & BITMAP_BYTE) === kind)
        .filter(([k]) => Number((k >> 48n) & BITMAP_BYTE) === domain)
        .filter(([k]) => {
          const c = Number((k >> 32n) & BITMAP_SHORT);
          return c === country || c === 0;
        })
        .filter(([k]) => Number((k >> 24n) & BITMAP_BYTE) === category)
        .filter(([k]) => Number((k >> 8n) & BITMAP_BYTE) === 0)
        .filter(([k]) => Number(k & BITMAP_BYTE) === 0)
        .map(([k, v]) => [Number((k >> 16n) & BITMAP_BYTE), v]),
    );
  }

  public getAllSpecificsOf(kind: number, domain: number, country: number, category: number, subcategory: number): Map<number, string> {
    return new Map(
      [...this.mapCategory.entries()]
        .filter(([k]) => Number((k >> 56n) & BITMAP_BYTE) === kind)
        .filter(([k]) => Number((k >> 48n) & BITMAP_BYTE) === domain)
        .filter(([k]) => {
          const c = Number((k >> 32n) & BITMAP_SHORT);
          return c === country || c === 0;
        })
        .filter(([k]) => Number((k >> 24n) & BITMAP_BYTE) === category)
        .filter(([k]) => Number((k >> 16n) & BITMAP_BYTE) === subcategory)
        .filter(([k]) => Number(k & BITMAP_BYTE) === 0)
        .map(([k, v]) => [Number((k >> 8n) & BITMAP_BYTE), v]),
    );
  }

  public getAllExtrasOf(kind: number, domain: number, country: number, cat: number, subcat: number, specific: number): Map<number, string> {
    return new Map(
      [...this.mapCategory.entries()]
        .filter(([k]) => Number((k >> 56n) & BITMAP_BYTE) === kind)
        .filter(([k]) => Number((k >> 48n) & BITMAP_BYTE) === domain)
        .filter(([k]) => {
          const c = Number((k >> 32n) & BITMAP_SHORT);
          return c === country || c === 0;
        })
        .filter(([k]) => Number((k >> 24n) & BITMAP_BYTE) === cat)
        .filter(([k]) => Number((k >> 16n) & BITMAP_BYTE) === subcat)
        .filter(([k]) => Number((k >> 8n) & BITMAP_BYTE) === specific)
        .map(([k, v]) => [Number(k & BITMAP_BYTE), v]),
    );
  }

  public searchDescription(query: string): Record<string, string> {
    return Object.fromEntries(
      [...this.mapCategory.entries()]
        .filter(([, v]) => v.toLowerCase().includes(query.toLowerCase()))
        .map((entry) => [SisoEnum.fromKey(entry[0]).toString(), entry[1]]),
    );
  }

  createKeyFor(se: SisoEnum): bigint {
    return Utils.createKey(se.kind, se.domain, se.country, se.category, se.subcategory, se.specific, se.extra);
  }

  getDescriptionOf(sisoEnum: SisoEnum): string {
    const key = this.createKeyFor(sisoEnum);
    const cat = this.getOrDefault(key);
    return cat;
  }

  createSisoEnumfromString(enumString: string): SisoEnum {
    return SisoEnum.fromString(enumString);
  }
}

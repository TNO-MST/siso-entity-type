import Long from "long";
import { EntityKindDescriptions, LongKeyMap, SisoEnum, Utils, type SisoEnumsDataType } from "./index.js";

import debugEsm from "debug";
const debug = debugEsm("SISO:enums");

// Bitmaps for entity type fields

export const BITMAP_0 = Long.fromString("0", true);
export const BITMAP_KIND = Long.fromString("ff00000000000000", true, 16);
export const BITMAP_KIND_DOMAIN = Long.fromString("ffff000000000000", true, 16);
export const BITMAP_KIND_DOMAIN_COUNTRY = Long.fromString("ffffffff00000000", true, 16);
export const BITMAP_COUNTRY = Long.fromString("0000ffff00000000", true, 16);
export const BITMAP_COUNTRY_CAT = Long.fromString("ffffffffff000000", true, 16);
export const BITMAP_COUNTRY_CAT_SUBCAT = Long.fromString("ffffffffffff0000", true, 16);
export const BITMAP_COUNTRY_CAT_SUBCAT_SPECIFIC = Long.fromString("ffffffffffffff00", true, 16);
export const BITMAP_0_CAT = Long.fromString("ffff0000ff000000", true, 16);
export const BITMAP_0_CAT_SUBCAT = Long.fromString("ffff0000ffff0000", true, 16);
export const BITMAP_0_CAT_SUBCAT_SPECIFIC = Long.fromString("ffff0000ffffff00", true, 16);
export const BITMAP_0_CAT_SUBCAT_SPECIFIC_EXTRA = Long.fromString("ffff0000ffffffff", true, 16);

export const BITMAP_BYTE = Long.fromInt(0xff);
export const BITMAP_SHORT = Long.fromInt(0xffff);

export class SisoEnums {
  private mapKind: LongKeyMap<string> = new LongKeyMap();
  private mapDomain: LongKeyMap<string> = new LongKeyMap();
  private mapCountry: LongKeyMap<string> = new LongKeyMap();
  private mapCategory: LongKeyMap<string> = new LongKeyMap();
  private mapSubcategory: LongKeyMap<string> = new LongKeyMap();
  private mapFullyQualifiedDescription: LongKeyMap<string> = new LongKeyMap();

  public get countryCount() {
    return this.mapCountry.size;
  }

  public get kindCount() {
    return this.mapKind.size;
  }

  public get domainCount() {
    return this.mapDomain.size;
  }

  public get categoryCount() {
    return this.mapCategory.size;
  }

  public get subcategoryCount() {
    return this.mapSubcategory.size;
  }

  constructor(enumsMap?: SisoEnumsDataType) {
    if (enumsMap != null) {
      this.initialize(enumsMap);
    }
  }

  // Loads the SISO enumeration data from a json file generated by the parser, either from an url when using a browser
  // or from the filesystem provided enumeration map when testing or running in NodeJS
  public async initialize(enumsMap: SisoEnumsDataType) {
    if (enumsMap == null) {
      throw new Error(`No enums map loaded, see README instructions`);
    } else {
      debug("Loading SISO enums from data...");
    }
    for (const [key, val] of Object.entries(enumsMap.countries)) {
      this.mapCountry.set(Long.fromString(key), val);
    }
    for (const [key, val] of Object.entries(enumsMap.domains)) {
      this.mapDomain.set(Long.fromString(key), val);
    }
    for (const [key, val] of Object.entries(enumsMap.categories)) {
      this.mapCategory.set(Long.fromString(key), val);
    }
    for (const [key, val] of Object.entries(enumsMap.subcategories)) {
      this.mapSubcategory.set(Long.fromString(key), val);
    }
    // Kinds are not loaded from the SISO enums datafile, but from the hardcoded EntityKind enum
    for (const [key, val] of Object.entries(EntityKindDescriptions)) {
      this.mapKind.set(Long.fromString(key).and(BITMAP_BYTE).shiftLeft(56), val);
    }
    debug(`Processed ${this.countryCount} countries`);
    debug(`Processed ${this.kindCount} kinds`);
    debug(`Processed ${this.domainCount} domains`);
    debug(`Processed ${this.categoryCount} categories`);
    debug(`Processed ${this.subcategoryCount} subcategories`);
  }

  private getOrDefault(entityType: SisoEnum, fullyQualified: boolean = false, defaultValue: string = "-"): string {
    const key = entityType.toKey();
    let text = null;
    if (fullyQualified) {
      if (this.mapFullyQualifiedDescription.has(key)) {
        text = this.mapFullyQualifiedDescription.get(key);
      } else {
        const category = this.getCategoryName(entityType);
        const subcategory = this.getSubcategoryName(entityType);
        const specific = this.getSpecificName(entityType);
        const extra = this.getExtraName(entityType);
        text = [category, subcategory, specific, extra]
          .filter((val, idx, arr) => val != null && (idx === 0 || val !== arr[idx - 1]))
          .join(" / ");
        text != null && this.mapFullyQualifiedDescription.set(key, text);
      }
    } else {
      text =
        this.mapSubcategory.get(key) ??
        this.mapSubcategory.get(key.and(BITMAP_0_CAT_SUBCAT_SPECIFIC_EXTRA)) ??
        this.mapSubcategory.get(key.and(BITMAP_COUNTRY_CAT_SUBCAT_SPECIFIC)) ??
        this.mapSubcategory.get(key.and(BITMAP_0_CAT_SUBCAT_SPECIFIC)) ??
        this.mapSubcategory.get(key.and(BITMAP_COUNTRY_CAT_SUBCAT)) ??
        this.mapSubcategory.get(key.and(BITMAP_0_CAT_SUBCAT)) ??
        this.mapSubcategory.get(key.and(BITMAP_COUNTRY_CAT)) ??
        this.mapSubcategory.get(key.and(BITMAP_KIND_DOMAIN_COUNTRY)) ??
        this.mapSubcategory.get(key.and(BITMAP_0_CAT)) ??
        this.mapSubcategory.get(key.and(BITMAP_KIND_DOMAIN)) ??
        defaultValue;
    }
    if (text == null) {
      text = defaultValue;
    }
    return text;
  }

  public getAllCountries(): Map<number, string> {
    const result = new Map<number, string>();
    this.mapCountry.forEach((value, key) => {
      result.set(key.shiftRight(32).toNumber(), value);
    });
    return result;
  }

  public getAllDomains(): Map<number, string> {
    const result = new Map<number, string>();
    this.mapDomain.forEach((value, key) => {
      result.set(key.shiftRight(48).toNumber(), value);
    });
    return result;
  }

  public getAllKinds(): Map<number, string> {
    const result = new Map<number, string>();
    this.mapKind.forEach((value, key) => {
      result.set(key.shiftRight(56).toNumber(), value);
    });
    return result;
  }

  public getAllDomainsOf(kind: number): Map<number, string> {
    return new Map(
      [...this.mapDomain.entries()]
        .filter(([k]) => k.shiftRight(56).and(BITMAP_BYTE).toNumber() === kind)
        .map(([k, v]) => [k.shiftRight(48).and(BITMAP_BYTE).toNumber(), v]),
    );
  }

  public getDescriptionOf(sisoEnum: SisoEnum, fullyQualified: boolean = false): string {
    return this.getOrDefault(sisoEnum, fullyQualified);
  }

  public getCountryName(countryOrEntity: SisoEnum | number): string {
    const country = typeof countryOrEntity === "number" ? countryOrEntity : countryOrEntity.country;
    return this.getAllCountries().get(country) || `Unknown country ${country}`;
  }

  public getKindName(kindOrEntity: SisoEnum | number): string {
    const kind = typeof kindOrEntity === "number" ? kindOrEntity : kindOrEntity.kind;
    return this.getAllKinds().get(kind) || `Unknown kind ${kind}`;
  }

  public getDomainName(ent: SisoEnum): string {
    return this.getAllDomainsOf(ent.kind).get(ent.domain) || `Unknown domain ${ent.domain}`;
  }

  public getCategoryName(ent: SisoEnum): string {
    return this.getAllCategoriesOf(ent.kind, ent.domain, ent.country).get(ent.category) || `Unknown category ${ent.category}`;
  }

  public getSubcategoryName(ent: SisoEnum): string {
    return (
      this.getAllSubcategoriesOf(ent.kind, ent.domain, ent.country, ent.category).get(ent.subcategory) ||
      `Unknown subcategory ${ent.subcategory}`
    );
  }

  public getSpecificName(ent: SisoEnum): string {
    return (
      this.getAllSpecificsOf(ent.kind, ent.domain, ent.country, ent.category, ent.subcategory).get(ent.specific) ||
      `Unknown specific ${ent.specific}`
    );
  }

  public getExtraName(ent: SisoEnum): string {
    return (
      this.getAllExtrasOf(ent.kind, ent.domain, ent.country, ent.category, ent.subcategory, ent.specific).get(ent.extra) ||
      `Unknown extra ${ent.extra}`
    );
  }

  public getAllCategoriesOf(kind: number, domain: number, country: number): Map<number, string> {
    return new Map(
      [...this.mapCategory.entries()]
        .filter(([k]) => k.shiftRight(56).and(BITMAP_BYTE).toNumber() === kind)
        .filter(([k]) => k.shiftRight(48).and(BITMAP_BYTE).toNumber() === domain)
        .filter(([k]) => {
          const c = k.shiftRight(32).and(BITMAP_SHORT).toNumber();
          return c === country || c === 0;
        })
        .filter(([k]) => k.shiftRight(16).and(BITMAP_BYTE).toNumber() === 0)
        .filter(([k]) => k.shiftRight(8).and(BITMAP_BYTE).toNumber() === 0)
        .filter(([k]) => k.and(BITMAP_BYTE).toNumber() === 0)
        .map(([k, v]) => [k.shiftRight(24).and(BITMAP_BYTE).toNumber(), v]),
    );
  }

  public getAllSubcategoriesOf(kind: number, domain: number, country: number, category: number): Map<number, string> {
    return new Map(
      [...this.mapSubcategory.entries()]
        .filter(([k]) => k.shiftRight(56).and(BITMAP_BYTE).toNumber() === kind)
        .filter(([k]) => k.shiftRight(48).and(BITMAP_BYTE).toNumber() === domain)
        .filter(([k]) => {
          const c = k.shiftRight(32).and(BITMAP_SHORT).toNumber();
          return c === country || c === 0;
        })
        .filter(([k]) => k.shiftRight(24).and(BITMAP_BYTE).toNumber() === category)
        .filter(([k]) => k.shiftRight(8).and(BITMAP_BYTE).toNumber() === 0)
        .filter(([k]) => k.and(BITMAP_BYTE).toNumber() === 0)
        .map(([k, v]) => [k.shiftRight(16).and(BITMAP_BYTE).toNumber(), v]),
    );
  }

  public getAllSpecificsOf(kind: number, domain: number, country: number, category: number, subcategory: number): Map<number, string> {
    return new Map(
      [...this.mapSubcategory.entries()]
        .filter(([k]) => k.shiftRight(56).and(BITMAP_BYTE).toNumber() === kind)
        .filter(([k]) => k.shiftRight(48).and(BITMAP_BYTE).toNumber() === domain)
        .filter(([k]) => {
          const c = k.shiftRight(32).and(BITMAP_SHORT).toNumber();
          return c === country || c === 0;
        })
        .filter(([k]) => k.shiftRight(24).and(BITMAP_BYTE).toNumber() === category)
        .filter(([k]) => k.shiftRight(16).and(BITMAP_BYTE).toNumber() === subcategory)
        .filter(([k]) => k.and(BITMAP_BYTE).toNumber() === 0)
        .map(([k, v]) => [k.shiftRight(8).and(BITMAP_BYTE).toNumber(), v]),
    );
  }

  public getAllExtrasOf(kind: number, domain: number, country: number, cat: number, subcat: number, specific: number): Map<number, string> {
    return new Map(
      [...this.mapSubcategory.entries()]
        .filter(([k]) => k.shiftRight(56).and(BITMAP_BYTE).toNumber() === kind)
        .filter(([k]) => k.shiftRight(48).and(BITMAP_BYTE).toNumber() === domain)
        .filter(([k]) => {
          const c = k.shiftRight(32).and(BITMAP_SHORT).toNumber();
          return c === country || c === 0;
        })
        .filter(([k]) => k.shiftRight(24).and(BITMAP_BYTE).toNumber() === cat)
        .filter(([k]) => k.shiftRight(16).and(BITMAP_BYTE).toNumber() === subcat)
        .filter(([k]) => k.shiftRight(8).and(BITMAP_BYTE).toNumber() === specific)
        .map(([k, v]) => [k.and(BITMAP_BYTE).toNumber(), v]),
    );
  }

  public searchDescription(query: string): Record<string, string> {
    return Object.fromEntries(
      [...this.mapSubcategory.entries()]
        .filter(([, v]) => v.toLowerCase().includes(query.toLowerCase()))
        .map((entry) => [SisoEnum.fromKey(entry[0]).toString(), entry[1]]),
    );
  }
}
